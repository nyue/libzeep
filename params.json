{"name":"Libzeep","tagline":"C++ library for reading and writing XML and creating web and SOAP servers","body":"Libzeep was developed to make it easy to create SOAP servers. And since\r\nworking with SOAP means working with XML and no decent C++ XML library\r\nexisted on my radar I've created a full XML library as well.\r\n\r\nThe XML part of libzeep consists of a validating parser, a DOM(-like) node\r\nimplementation, an XPath search engine and a XML writer/formatter. The\r\nvalidation works based on DOCTYPE definitions, XML schema support will be\r\nadded in a later release.\r\n\r\nThe performance of the parser is not optimal yet although it performs very\r\ndecently. If speed is critical and you really need that few percent saving\r\nyou can choose to use expat as a parser instead.\r\n\r\nPlease note that libzeep aims to provide a fully compliant XML processor as\r\nspecified by the W3 organisation (see: http://www.w3.org/TR/xml ). This means\r\nit is as strict as the standard requires and it stops processing a file when\r\na validation of the well-formedness is encountered, or when a document\r\nappears to be invalid when it is in validating mode. Error reporting is done\r\nin this case, although I admit that error reporting should be improved.\r\n\r\nThe SOAP server part of libzeep makes it very easy to create a SOAP server\r\nsoftware in C++. You use it to export a C++ object's methods as SOAP actions.\r\nThe library generates a WSDL on-the-fly for the exported actions and it also\r\nhas a REST style interface.\r\n\r\nlibzeep requires the Boost libraries and currently requires at least version\r\n1.36 of Boost since it uses the new asio library for network I/O. The current\r\nversion of libzeep has been tested with boost 1.39 and newer only.\r\n\r\nTo use libzeep, you have to edit the makefile and make sure the paths to your\r\ninstallation of boost libraries are correct. After this you simply type\r\n'make zeep-test' and a 'zeep-test' executable is build. You can also cd into\r\nthe tests directory and build the two test applications called xpath-test and\r\nparser-test. For Windows users there's a VC solution file in the msvc\r\ndirectory.\r\n\r\n## XML Library -- usage\r\n\r\nUsing the XML library of libzeep is fairly trivial. The first class you use\r\nis the zeep::xml::document class. You can use this class to read XML files\r\nand write them out again. Reading and writing is strictly done using stl\r\niostreams. Make sure you open these streams in binary mode, random parsing\r\nerrors will occur if you don't when running in Windows.\r\n\r\n\t#include <fstream>\r\n\t#include \"zeep/xml/document.hpp\"\r\n\t\r\n\tusing namespace std;\r\n\tusing namespace zeep;\r\n\t\r\n\t...\r\n\t\r\n\txml::document doc;\r\n\tdoc.set_validating(true);\t\t\t// validation is off by default\r\n\tifstream file(\"/...\", ios::binary); // avoid CRLF translation\r\n\tfile >> doc;\r\n\t\r\nNow that you have a document, you can walk its content which is organised in\r\nnodes. There are several nodes classes, the most interesting for most is\r\nxml::element. These elements can have children, some of which are also\r\nelements.\r\n\r\nInternally the nodes are stored as linked lists. However, to conform to STL\r\ncoding practices, xml::element can used like a container. The iterator of\r\nxml::element (which it inherits from its base class xml::container) only\r\nreturns child xml::element objects skipping over comments and processing\r\ninstructions.\r\n\r\nSo, to iterate over all elements directly under the first element of a\r\ndocument, we do something like this:\r\n\r\n\txml::element& first = *doc.child();\r\n\tfor (xml::document::iterator e = first.begin(); e != first.end(); ++e)\r\n\t\tcout << e.name() << endl;\r\n\r\nLikewise you can iterate over the attributes of an xml::element, like this:\r\n\r\n\tfor (xml::element::attribute_iterator a = e.attr_begin(); a != e.attr_end(); ++a)\r\n\t\tcout << a->name() << endl;\r\n\r\nMore often you're interested in a specific element among many others. Now you\r\ncan recursively iterate the tree until you've found what you're looking for,\r\nbut it is way easier to use xpaths in that case. Let say you need the element\r\n'book' having an attribute 'title' with value 'Du côté de chez Swann', you\r\ncould do this:\r\n\r\n\txml::element* book = doc.find(\"//book[@title='Du côté de chez Swann']\");\r\n\r\nYou can access the attributes by name:\r\n\r\n\tassert(book->get_attribute(\"author\") == \"Proust\");\r\n\r\nAnd the content, contained in the text nodes of an element:\r\n\t\r\n\tcout << book->content() << endl;\r\n\r\nAnd writing out an XML file again can be done by writing an xml::document:\r\n\r\n\tcout << doc;\r\n\t\r\nOr by using xml::writer directly.\r\n\r\nlibzeep has XML Namespace support. The qname method of the nodes returns a\r\nqualified name, that is the namespace prefix, a colon and the localname\r\ncontatenated. (Something like 'ns:book'). The method name() returns the\r\nqname() with its prefix stripped off.\r\n\r\nSOAP Server -- usage\r\n\r\nHave a look at the zeep-test.cpp file to see how to create a server. This\r\nexample server is not entirely trivial since it has three exported methods\r\nthat each take another set of parameters.\r\n\r\nWhen you run this sample server, it listens to port 10333 on your localhost.\r\nYou can access the wsdl by pointing your browser at:\r\n\r\nhttp://localhost:10333/wsdl\r\n\r\nand to access e.g. the Count method of this server from the REST interface\r\nyou can browse to:\r\n\r\nhttp://localhost:10333/rest/Count/db/sprot/booleanquery/os:human\r\n\r\nAs you can see, parameters and values are passed in the URL, order is not\r\nimportant and multiple id/value pairs can be specified for input parameters\r\nthat allow more than one value.\r\n\r\nThe steps to create a server are:\r\n\r\nCreate a new server object that derives from soap::server. The constructor\r\nof this object should call the inherited constructor passing it the\r\nnamespace and the service name for this new SOAP server as well as the\r\ninternet address and port to listen to.\r\n\r\nInside the constructor of your new server object you have to register the\r\nmethods of the server you want to export. These methods can take any number\r\nof input arguments and only one output parameter which is the last parameter\r\nof the method. The result of these methods should be void.\r\n\r\nPlease note that if the method's last (output) parameter is a struct, then\r\nthe fields of this struct will be moved up in the Response message of the\r\naction in the WSDL. To the outside world this method will look like it has\r\nmultiple output parameters. This was done to be compatible with another\r\npopular SOAP tool but the result may be a bit confusing at times.\r\n\r\nTo register the methods you have to call the inherited 'register_action'\r\nmethod which takes four parameters:\r\n\r\n- the name of the action as it is published\r\n- the pointer for your server object, usually it is 'this'.\r\n- a pointer to the method of your server object you want to export\r\n- an array of pointers to the exported names for each of the parameters\r\n\tof the exported method/action. The size of this array should be exactly\r\n\tas long as the arity of your method. You will get a compilation error\r\n\tif it isn't.\r\n\r\nIf you export enum parameters, you add the names for all possible values of \r\nyour enumerated type by using the SOAP_XML_ADD_ENUM macro. The first parameter\r\nshould be the name of the enum type, the second the value identifier.\r\n\r\nIf you have structured types you want to export, you have to do two things.\r\nFirst of all the structure needs to be able to serialize itself. You do this\r\nby adding the method serialize to each struct. For a struct consisting of two \r\nfields, db and id, you specify:\r\n\r\n\ttemplate<class Archive>\r\n\tvoid serialize(Archive& ar, const unsigned int version)\r\n\t{\r\n\t\tar & BOOST_SERIALIZATION_NVP(db)\r\n\t\t   & BOOST_SERIALIZATION_NVP(id);\r\n\t}\r\n\r\nThe next thing you need for each struct is to set its exported name using the\r\nSOAP_XML_SET_STRUCT_NAME macro.\r\n\r\nAnd that's it. The moment the constructor is done, your server is ready to\r\nrun. You can start it by calling the 'run' method, normally you do this from\r\na new thread. The servers will start listening to the address and port you\r\nspecified. Beware though that the server is multithreaded and so your exported\r\nmethods should be reentrant. The number of threads the server will use can be\r\nspecified in the constructor of the soap::server base class.\r\n\r\nIf your server is behind a reverse proxy, you set the actual location in the\r\nWSDL from which it is accessible by calling the server's set_location method.\r\n\r\nInside your server method you have access to the ostream object used to write\r\nout log entries by using the inherited log() member function.\r\n\r\nThat's it.\r\n\r\nThis is a first release, please send all the problems and/or bugs you encounter\r\nto: maarten@hekkelman.com\r\n\r\n-maarten hekkelman\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}